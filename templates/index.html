<!DOCTYPE html>
<html>
<head>
    <title>Whiteboard Web App</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
</head>
<body onload="initializeDarkMode()">
    <div class="controls">
        <button id="addMagnetBtn" onclick="addMagnet()">Add Magnet</button>
        <button onclick="addNote()">Add Note</button>
        <button onclick="recoverElements()" title="Recover elements that have moved offscreen">Recover</button>
        <span>Dark Mode:</span>
        <label class="switch">
            <input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode()">
            <span class="slider"></span>
        </label>
        <button class="reset-btn" onclick="resetWhiteboard()">Reset</button>
    </div>

    <div id="whiteboard"></div>
    
    <!-- Tenor GIF Search Modal -->
    <div id="gifModal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeGifModal()">&times;</span>
            <h2>Search Tenor GIFs</h2>
            <div class="search-container">
                <input type="text" id="gifSearchInput" placeholder="Search for GIFs..." oninput="debouncedSearch()">
                <button onclick="searchGifs()">Search</button>
            </div>
            <div id="gifResults" class="gif-results"></div>
        </div>
    </div>

    <script>
    let selectedElement = null;
    let isDragging = false;
    let isResizing = false;
    let resizeHandle = null;
    const TENOR_API_KEY = "LIVDSRZULELA"; // Demo API key, replace with your own
    let currentGifTarget = null;
    let debounceTimer;

    // Generate & store userId in localStorage if none exists
    let userId = localStorage.getItem('userId');
    if (!userId) {
        userId = 'user_' + Date.now() + '_' + Math.floor(Math.random()*1000);
        localStorage.setItem('userId', userId);
    }

    // Load user whiteboard on page load
    window.addEventListener('load', () => {
        loadWhiteboardData();
    });

    // Save whiteboard automatically when elements change or on beforeunload
    function scheduleSave() {
        saveWhiteboardData();
    }

    window.addEventListener('beforeunload', () => {
        saveWhiteboardData();
    });

    function loadWhiteboardData() {
        fetch(`/api/whiteboard?userId=${encodeURIComponent(userId)}`)
        .then(response => response.json())
        .then(data => {
            if (!data || !data.elements) return;
            data.elements.forEach(element => {
                if (element.type === 'magnet') {
                    const magnet = document.createElement('div');
                    magnet.className = 'magnet';
                    magnet.style.left = element.left;
                    magnet.style.top = element.top;
                    magnet.style.width = element.width;
                    magnet.style.height = element.height;
                    magnet.innerHTML = element.content;
                    setupElementEvents(magnet);
                    document.getElementById('whiteboard').appendChild(magnet);
                } else if (element.type === 'note') {
                    const note = document.createElement('div');
                    note.className = 'note';
                    note.style.left = element.left;
                    note.style.top = element.top;
                    note.style.width = element.width;
                    note.style.height = element.height;
                    note.innerHTML = element.content;
                    setupElementEvents(note);
                    document.getElementById('whiteboard').appendChild(note);
                }
            });
        })
        .catch(err => console.error('Load error:', err));
    }

    function saveWhiteboardData() {
        const elements = [];
        document.querySelectorAll('.magnet, .note').forEach(el => {
            const rect = el.getBoundingClientRect();
            elements.push({
                type: el.classList.contains('magnet') ? 'magnet' : 'note',
                left: el.style.left,
                top: el.style.top,
                width: rect.width + 'px', // Use actual width
                height: rect.height + 'px', // Use actual height
                content: el.innerHTML
            });
        });

        fetch('/api/whiteboard', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ userId, elements })
        })
        .catch(err => console.error('Save error:', err));
    }

    function toggleDarkMode() {
        document.body.classList.toggle('dark-mode');
        localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
    }

    function initializeDarkMode() {
        const darkPref = localStorage.getItem('darkMode');
        if (darkPref === 'true') {
            document.body.classList.add('dark-mode');
            document.getElementById('darkModeToggle').checked = true;
        }
    }

    // Keep track of attached elements
    let attachedElements = {};

    function startDrag(e, element) {
        e.preventDefault();
        selectedElement = element;
        isDragging = true;
        const rect = element.getBoundingClientRect();
        selectedElement.offsetX = e.clientX - rect.left;
        selectedElement.offsetY = e.clientY - rect.top;
        
        // If dragging a note, find attached magnets
        if (element.classList.contains('note')) {
            attachedElements = findAttachedElements(element);
        }
    }
    
    // Find magnets that are attached to this element
    function findAttachedElements(element) {
        const attached = {};
        const elementRect = element.getBoundingClientRect();
        const snapDistance = 15; // Same as snap distance
        
        document.querySelectorAll('.magnet').forEach(magnet => {
            const magnetRect = magnet.getBoundingClientRect();
            
            // Check if this magnet is attached to the element (close enough to be considered attached)
            const isAttachedHorizontally = 
                Math.abs(magnetRect.left - elementRect.right) < snapDistance || 
                Math.abs(magnetRect.right - elementRect.left) < snapDistance ||
                Math.abs(magnetRect.left - elementRect.left) < snapDistance ||
                Math.abs(magnetRect.right - elementRect.right) < snapDistance;
                
            const isAttachedVertically = 
                Math.abs(magnetRect.top - elementRect.bottom) < snapDistance || 
                Math.abs(magnetRect.bottom - elementRect.top) < snapDistance ||
                Math.abs(magnetRect.top - elementRect.top) < snapDistance ||
                Math.abs(magnetRect.bottom - elementRect.bottom) < snapDistance;
                
            if (isAttachedHorizontally || isAttachedVertically) {
                // Store the relative position of the magnet to the note
                attached[magnet.id || Date.now() + Math.random()] = {
                    element: magnet,
                    offsetX: elementRect.left - magnetRect.left,
                    offsetY: elementRect.top - magnetRect.top
                };
                
                // Ensure magnet has an ID for tracking
                if (!magnet.id) {
                    magnet.id = 'magnet-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
                }
            }
        });
        
        return attached;
    }

    document.onmousemove = (e) => {
        if (isDragging && selectedElement) {
            const originalLeft = parseInt(selectedElement.style.left) || 0;
            const originalTop = parseInt(selectedElement.style.top) || 0;

            const newLeft = e.clientX - selectedElement.offsetX;
            const newTop = e.clientY - selectedElement.offsetY;

            const maxLeft = window.innerWidth - 50;
            const maxTop = window.innerHeight - 50;

            const boundedLeft = Math.max(0, Math.min(newLeft, maxLeft));
            const boundedTop = Math.max(0, Math.min(newTop, maxTop));

            // Move the selected element
            selectedElement.style.left = boundedLeft + 'px';
            selectedElement.style.top = boundedTop + 'px';
            
            // Also move any attached elements
            if (selectedElement.classList.contains('note')) {
                Object.values(attachedElements).forEach(info => {
                    const magnet = info.element;
                    // Move the magnet maintaining the same relative position
                    const magnetLeft = boundedLeft - info.offsetX;
                    const magnetTop = boundedTop - info.offsetY;
                    
                    // Ensure the magnet stays within bounds
                    const maxMagnetLeft = window.innerWidth - parseInt(magnet.style.width || 150);
                    const maxMagnetTop = window.innerHeight - parseInt(magnet.style.height || 100);
                    
                    magnet.style.left = Math.max(0, Math.min(magnetLeft, maxMagnetLeft)) + 'px';
                    magnet.style.top = Math.max(0, Math.min(magnetTop, maxMagnetTop)) + 'px';
                });
            }
            
            snapToNearbyElements(selectedElement, 15); // Reduced snap range for more precision
            scheduleSave();
        } else if (isResizing && resizeHandle) {
            const element = resizeHandle.element;
            const width = resizeHandle.startWidth + (e.clientX - resizeHandle.startX);
            const height = resizeHandle.startHeight + (e.clientY - resizeHandle.startY);

            if (width > 100) element.style.width = width + 'px';
            if (height > 100) element.style.height = height + 'px';
            scheduleSave();
        }
    };

    document.addEventListener('touchmove', function(e) {
        if (isDragging && selectedElement) {
            e.preventDefault();

            const touch = e.touches[0];

            const originalLeft = parseInt(selectedElement.style.left) || 0;
            const originalTop = parseInt(selectedElement.style.top) || 0;

            const newLeft = touch.clientX - selectedElement.offsetX;
            const newTop = touch.clientY - selectedElement.offsetY;

            const maxLeft = window.innerWidth - 50;
            const maxTop = window.innerHeight - 50;

            const boundedLeft = Math.max(0, Math.min(newLeft, maxLeft));
            const boundedTop = Math.max(0, Math.min(newTop, maxTop));

            // Move the selected element
            selectedElement.style.left = boundedLeft + 'px';
            selectedElement.style.top = boundedTop + 'px';
            
            // Also move any attached elements
            if (selectedElement.classList.contains('note')) {
                Object.values(attachedElements).forEach(info => {
                    const magnet = info.element;
                    // Move the magnet maintaining the same relative position
                    const magnetLeft = boundedLeft - info.offsetX;
                    const magnetTop = boundedTop - info.offsetY;
                    
                    // Ensure the magnet stays within bounds
                    const maxMagnetLeft = window.innerWidth - parseInt(magnet.style.width || 150);
                    const maxMagnetTop = window.innerHeight - parseInt(magnet.style.height || 100);
                    
                    magnet.style.left = Math.max(0, Math.min(magnetLeft, maxMagnetLeft)) + 'px';
                    magnet.style.top = Math.max(0, Math.min(magnetTop, maxMagnetTop)) + 'px';
                });
            }
            
            snapToNearbyElements(selectedElement, 20);
            scheduleSave();
        } else if (isResizing && resizeHandle) {
            const touch = e.touches[0];
            const element = resizeHandle.element;
            const width = resizeHandle.startWidth + (touch.clientX - resizeHandle.startX);
            const height = resizeHandle.startHeight + (touch.clientY - resizeHandle.startY);

            if (width > 100) element.style.width = width + 'px';
            if (height > 100) element.style.height = height + 'px';
            scheduleSave();
        }
    }, { passive: false });

    document.addEventListener('touchend', function(e) {
        isDragging = false;
        isResizing = false;
        selectedElement = null;
        resizeHandle = null;
        attachedElements = {}; // Clear the attached elements
    });

    document.onmouseup = () => {
        isDragging = false;
        isResizing = false;
        selectedElement = null;
        resizeHandle = null;
        attachedElements = {}; // Clear the attached elements
    };

    function addMagnet() {
        const magnet = document.createElement('div');
        magnet.className = 'magnet';
        magnet.style.zIndex = 1000;
        magnet.id = 'magnet-' + Date.now() + '-' + Math.floor(Math.random() * 1000);

        const fileInputId = 'file-input-' + Date.now();

        magnet.innerHTML = `
            <button class="close-btn" onclick="removeElement(this)">X</button>
            <div class="magnet-header"><span class="drag-icon">≡</span></div>
            <input type="file" id="${fileInputId}" accept="image/*" onchange="updateImage(this)" style="display:none">
            <div class="button-container">
                <button class="small-btn upload-btn" onclick="document.getElementById('${fileInputId}').click()">Upload Image</button>
                <button class="small-btn gif-btn" onclick="openGifModal(this)">Search GIFs</button>
                <button class="small-btn paste-btn" onclick="requestClipboardPaste(this)">Paste</button>
            </div>
            <div class="content-container"></div>
            <div class="resize-handle"></div>
            <div class="context-menu">
                <div class="menu-item" onclick="requestClipboardPaste(this.closest('.magnet').querySelector('.paste-btn'))">Paste from clipboard</div>
            </div>
        `;

        magnet.style.left = (Math.random() * (window.innerWidth - 200)) + 'px';
        magnet.style.top = (Math.random() * (window.innerHeight - 200)) + 'px';

        setupElementEvents(magnet);
        document.getElementById('whiteboard').appendChild(magnet);
        scheduleSave();
    }

    function addNote() {
        const note = document.createElement('div');
        note.className = 'note';
        note.style.zIndex = 100;
        note.id = 'note-' + Date.now() + '-' + Math.floor(Math.random() * 1000);

        note.innerHTML = `
            <button class="close-btn" onclick="removeElement(this)">X</button>
            <div class="note-header"><span class="drag-icon">≡</span></div>
            <div contenteditable="true" style="padding:10px; min-height:50px; height:calc(100% - 50px); overflow-y:auto"></div>
            <div class="resize-handle"></div>
        `;

        note.style.left = (Math.random() * (window.innerWidth - 200)) + 'px';
        note.style.top = (Math.random() * (window.innerHeight - 200)) + 'px';

        setupElementEvents(note);
        document.getElementById('whiteboard').appendChild(note);
        scheduleSave();
    }

    function setupElementEvents(element) {
        const header = element.querySelector('.magnet-header, .note-header');
        header.addEventListener('mousedown', function(e) {
            startDrag(e, element);
        });

        header.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const touchEvent = {
                clientX: touch.clientX,
                clientY: touch.clientY,
                preventDefault: function() {}
            };
            startDrag(touchEvent, element);
        }, { passive: false });

        const resizer = element.querySelector('.resize-handle');
        resizer.addEventListener('mousedown', function(e) {
            e.preventDefault();
            e.stopPropagation();
            isResizing = true;
            resizeHandle = {
                element: element,
                startX: e.clientX,
                startY: e.clientY,
                startWidth: parseInt(document.defaultView.getComputedStyle(element).width, 10),
                startHeight: parseInt(document.defaultView.getComputedStyle(element).height, 10)
            };
        });

        resizer.addEventListener('touchstart', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const touch = e.touches[0];
            isResizing = true;
            resizeHandle = {
                element: element,
                startX: touch.clientX,
                startY: touch.clientY,
                startWidth: parseInt(document.defaultView.getComputedStyle(element).width, 10),
                startHeight: parseInt(document.defaultView.getComputedStyle(element).height, 10)
            };
        }, { passive: false });

        if (element.classList.contains('magnet')) {
            element.addEventListener('contextmenu', function(e) {
                e.preventDefault();

                const contextMenu = element.querySelector('.context-menu');
                if (contextMenu) {
                    contextMenu.style.left = (e.clientX - element.getBoundingClientRect().left) + 'px';
                    contextMenu.style.top = (e.clientY - element.getBoundingClientRect().top) + 'px';
                    contextMenu.style.display = 'block';

                    const closeMenu = function(event) {
                        if (!contextMenu.contains(event.target)) {
                            contextMenu.style.display = 'none';
                            document.removeEventListener('click', closeMenu);
                        }
                    };

                    setTimeout(() => {
                        document.addEventListener('click', closeMenu);
                    }, 100);
                }
            });
        }
    }

    // Improved snap function to make elements stick together like magnets
    function snapToNearbyElements(el, distance) {
        const others = document.querySelectorAll('.magnet, .note');
        const elRect = el.getBoundingClientRect();
        let snapped = false;
        
        // Check for snapping to the edges of other elements
        others.forEach(other => {
            if (other === el) return; // Skip self
            
            const oRect = other.getBoundingClientRect();
            
            // Calculate edges for both elements
            const elEdges = {
                left: elRect.left,
                right: elRect.right,
                top: elRect.top,
                bottom: elRect.bottom
            };
            
            const otherEdges = {
                left: oRect.left,
                right: oRect.right,
                top: oRect.top,
                bottom: oRect.bottom
            };
            
            // Horizontal snapping
            // Snap left edge to right edge
            if (Math.abs(elEdges.left - otherEdges.right) < distance) {
                el.style.left = (otherEdges.right) + 'px';
                snapped = true;
            }
            // Snap right edge to left edge
            else if (Math.abs(elEdges.right - otherEdges.left) < distance) {
                el.style.left = (otherEdges.left - elRect.width) + 'px';
                snapped = true;
            }
            // Align left edges
            else if (Math.abs(elEdges.left - otherEdges.left) < distance) {
                el.style.left = otherEdges.left + 'px';
                snapped = true;
            }
            // Align right edges
            else if (Math.abs(elEdges.right - otherEdges.right) < distance) {
                el.style.left = (otherEdges.right - elRect.width) + 'px';
                snapped = true;
            }
            
            // Vertical snapping
            // Snap top edge to bottom edge
            if (Math.abs(elEdges.top - otherEdges.bottom) < distance) {
                el.style.top = (otherEdges.bottom) + 'px';
                snapped = true;
            }
            // Snap bottom edge to top edge
            else if (Math.abs(elEdges.bottom - otherEdges.top) < distance) {
                el.style.top = (otherEdges.top - elRect.height) + 'px';
                snapped = true;
            }
            // Align top edges
            else if (Math.abs(elEdges.top - otherEdges.top) < distance) {
                el.style.top = otherEdges.top + 'px';
                snapped = true;
            }
            // Align bottom edges
            else if (Math.abs(elEdges.bottom - otherEdges.bottom) < distance) {
                el.style.top = (otherEdges.bottom - elRect.height) + 'px';
                snapped = true;
            }
        });
        
        return snapped;
    }

    function recoverElements() {
        let recoveredElements = 0;
        const whiteboard = document.getElementById('whiteboard');
        const maxRight = window.innerWidth - 200;
        const maxBottom = window.innerHeight - 200;

        document.querySelectorAll('.magnet, .note').forEach(element => {
            const rect = element.getBoundingClientRect();
            let needsRepositioning = false;

            if (rect.left < 0 || rect.top < 0 || rect.right > window.innerWidth || rect.bottom > window.innerHeight) {
                needsRepositioning = true;
            }

            const header = element.querySelector('.magnet-header, .note-header');
            if (header) {
                const headerRect = header.getBoundingClientRect();
                if (headerRect.top < 0 || headerRect.left < 0 || headerRect.right > window.innerWidth) {
                    needsRepositioning = true;
                }
            }

            if (needsRepositioning) {
                element.style.left = Math.min(Math.max(50, rect.left), maxRight) + 'px';
                element.style.top = Math.min(Math.max(50, rect.top), maxBottom) + 'px';
                recoveredElements++;
            }
        });

        if (recoveredElements > 0) {
            alert(`Recovered ${recoveredElements} element(s) that were difficult to access.`);
        } else {
            alert('No elements needed recovery.');
        }
        scheduleSave();
    }

    function removeElement(element) {
        const parent = element.parentElement;
        parent.remove();
        scheduleSave();
    }

    function updateImage(input) {
        if (input.files && input.files[0]) {
            const file = input.files[0];
            const reader = new FileReader();

            const magnet = input.closest('.magnet');
            const container = magnet.querySelector('.content-container');
            container.innerHTML = '<div class="loading">Loading image...</div>';

            reader.onload = (e) => {
                try {
                    container.innerHTML = ''; 
                    const img = document.createElement('img');
                    img.src = e.target.result;
                    img.alt = "Magnet Image";
                    img.style.maxWidth = "100%";
                    img.style.maxHeight = "100%";
                    container.appendChild(img);

                    const buttonContainer = magnet.querySelector('.button-container');
                    if (buttonContainer) {
                        buttonContainer.remove();
                    }
                    scheduleSave();
                } catch (error) {
                    console.error("Error processing image:", error);
                    container.innerHTML = '<div class="error">Failed to load image</div>';
                }
            };

            reader.onerror = (error) => {
                console.error("Error reading file:", error);
                container.innerHTML = '<div class="error">Failed to load image</div>';
            };

            reader.readAsDataURL(file);
        }
    }

    function resetWhiteboard() {
        if (confirm('Are you sure you want to reset the whiteboard? This will remove all items.')) {
            document.getElementById('whiteboard').innerHTML = '';
            scheduleSave();
        }
    }
    </script>
</body>
</html>